---
title: "Class 13: Transcriptomics and the analysis of RNA-Seq data"
author: "Kris Price (PID: A17464127)"
format: pdf
toc: true
---

## Background

Today we will perform an RNASeq analysis of the effects of a common steroid on airway cells.

In particular, dexamethasone (hereafter, just called "dex") on different airway smooth muscle cell lines (ASM cells).

## Data Import

We need two different inputs:

- **countData**: with genes in rows and experiments in columns
- **colData**: metadata that describes the columns in countData

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")

head(counts)

head(metadata)
```

> Q1. How many genes are in this dataset?

```{r}
nrow(counts)
```

There are 38,694 genes in this dataset.

> Q2. How many ‘control’ cell lines do we have?

```{r}
table(metadata$dex)

# or we could do sum(metadata$dex == "control")
```

There's 4 'control' cell lines.

## Differential Gene Expression

We have 4 replicate drug treated and control (no drug) columns/experiments in our `counts` object.

We want one "mean" value for each gene (rows) in "treated" (drug) and one mean value for each gene in "control" cols.

Step 1. Find all "control" columns in `counts`
Step 2. Extract these columns to a new object called `control.counts`
Step 3. Then calculate the mean value for each gene

```{r, message = FALSE}
library(tidyverse)
```


```{r}
control.counts <- metadata %>%
  filter(dex == "control") %>%
  pull(id)

control.mean <- counts %>%
  select(control.counts) %>%
  rowMeans()

head(control.mean)
```

> Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

Instead of defining `control.means` with `rowSums(control.counts)/4`, you could just directly calculate the mean using `rowMeans(control.counts)`.

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

Now do the same thing for the "treated" columns/experiments...

```{r}
treated.counts <- metadata %>%
  filter(dex == "treated") %>%
  pull(id)

treated.mean <- counts %>%
  select(treated.counts) %>%
  rowMeans()

head(treated.mean)
```

> Q5. Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

Put these together for easy book-keeping as a `mean.counts` dataframe. Then, create a quick plot (note that, when using ggplot, you can create this same plot using `geom_point()`:

```{r}
mean.counts <- data.frame(control.mean, treated.mean)

plot(mean.counts)
```

> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

Let's log transform this count data, using the `log = ` argument:

```{r}
plot(mean.counts, log = "xy")
```

**N.B.** We most often use log2 for this type of data as it makes the interpretation much more straightforward.

Treated/Control is often called "fold-change"

If there was no change, we would have a log2-fc of 0:
```{r}
log2(10/10)
```


If we had double the amount of transcript around, we'd have a log2-fc of 1:
```{r}
log2(20/10)
```


If we had half as much transcript around, we'd have a log2-fc of -1:
```{r}
log2(5/10)
```

> Q. Calculate a log2 fold change value for all our genes and add it as a new column to our `mean.counts` object.

```{r}
mean.counts <- mean.counts %>%
  mutate(log.fc = log2(treated.mean / control.mean))

head(mean.counts)
```

There's some "funky" log2fc values (NaN and -Inf) here that come about whenever we have 0 mean count values. Typically we would remove these genes from any further analysis, as we can't say anything about them if we have no data for them.

```{r}
zero.vals <- which(mean.counts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- mean.counts[-to.rm,]
head(mycounts)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The `arr.ind` argument causes the `which()` function to return the array indices (AKA both the row and column indices) where the mean count is 0. The `unique()` function ensures that each row can only be counted up to one time, even if it has a mean of 0 in both experiments.

```{r}
up.ind <- mycounts$log.fc > 2
down.ind <- mycounts$log.fc < (-2)
```

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

```{r}
sum(up.ind)
```
There are 250 up-regulated genes that are greater than 2 fc level.

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

```{r}
sum(down.ind)
```

There are 367 down-regulated genes that are greater than 2 fc level.

> Q10. Do you trust these results? Why or why not?

I would not readily trust these results because even though these genes show such a large difference in expression across treatments, there are no measurements of statistical significance.

## DESeq Analysis

Let's do this analysis with an estimate of statistical significance using the **DESEq2** package.

```{r, message = FALSE}
library(DESeq2)
```

DESeq2 (like many BioConductor packages) wants its input data in a very specific way.

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts, colData = metadata, design = ~dex)
```

### Run the DESeq analysis pipeline

The main function `DESeq()`

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)

head(res)
```

## Volcano Plot

This is a main summary results figure from these kinds of studies. It's a plot of log2 fold-change vs. adjusted p-value.

```{r}
plot(res$log2FoldChange, res$padj)
```

Again, this y-axis is highly skewed, and needs log transforming. We can flip the y-axis with a minus sign so it looks like every other volcano plot.

```{r}
plot(res$log2FoldChange, -log(res$padj))

abline(v = -2, col = "red")
abline(v = 2, col = "red")
abline(h = -log(0.05), col = "red")
```

### Adding some color annotation 

Start with a default base color "gray"

```{r}
mycols <- rep("gray", nrow(res))

mycols[res$log2FoldChange > 2] <- "blue"
mycols[res$log2FoldChange < -2] <- "darkgreen"
mycols[res$padj >= 0.05] <- "gray"

plot(res$log2FoldChange, -log(res$padj), col = mycols)
```

> Q. Make a presentation- quality ggplot version of this plot. Include clear axis labels, a clean theme, your custom colors, cut-off lines and a plot title.

```{r}
ggplot(res, aes(log2FoldChange, -log(padj))) +
  geom_point(col = mycols) +
  geom_vline(aes(xintercept = -2)) +
  geom_vline(aes(xintercept = 2)) +
  geom_hline(aes(yintercept = -log(0.05))) +
  labs(title = "Log2 Fold-Change vs. Adjusted P-value") +
  ylab("Adjusted P-value (log-transformed)") +
  theme_bw()
```

## Save our results

Write a CSV file:

```{r}
write.csv(res, file = "results.csv")
```

## Add annotation data

We need to add missing annotation data to our main `res` results object. This includes the common gene "symbol"

```{r}
head(res)
```

We will use R and bioconductor to do this "ID mapping"

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

Let's see what databases we can use for translation/mapping...

```{r}
columns(org.Hs.eg.db)
```

We can use the `mapIds()` function now to "translate" between any of these databases.

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys = row.names(res), # Our gene names
                     keytype = "ENSEMBL", # The format of our gene names
                     column = "SYMBOL") # The new format we want to add
```

```{r}
head(res)
```

> Q. Also add "ENTReZID", "GENENAME" IDs to our `res` object:

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys = row.names(res),
                     keytype = "ENSEMBL",
                     column = "ENTREZID")
  
res$genename <- mapIds(org.Hs.eg.db,
                     keys = row.names(res),
                     keytype = "ENSEMBL",
                     column = "GENENAME")

head(res)
```

## Save annotated results to a CSV file

```{r}
write.csv(res, "results_annotated.csv")
```

## Pathway Analysis

What known biological pathways do our differentially expressed genes overlap with (i.e. play a role in)?

There's lots of bioconductor packages to do this type of analysis.

We will use one of the oldest, called **gage**, along with **pathview** to render nice pictures of the pathways we find.

```{r, message = FALSE}
library(pathview)
library(gage)
library(gageData)
```

Have a little peak into what's in `gageData`:

```{r}
data(kegg.sets.hs)
head(kegg.sets.hs, 2)
```

The main `gage()` function that does the work wants a simple vector as input.

```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$entrez # The KEGG database uses ENTREZ IDs, so we need to provide these in our input vector for gage

head(foldchanges)
```

Now we can run `gage()`

```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

What's in the output object `keggres`?

```{r}
attributes(keggres)
```

```{r}
# Look in the first three down (less) pathways
head(keggres$less, 3)
```

We can use the **pathview** function to render a figure of any of these pathways along with annotation for our DEGs.

Let's see the hsa05310 Asthma pathway with our DEGs colored up:

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```

![](hsa05310.pathview.png)

> Q. Can you render and insert here the pathway figure for "Graft-versus-host disease" and "Type I diabetes?"

Graft-versus-host disease:

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05332")
```

![Graft-versus-host disease pathview](hsa05332.pathview.png)

Type I diabetes:

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa04940")
```

![Type I diabetes pathview](hsa04940.pathview.png)




